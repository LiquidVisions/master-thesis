\chapter{Introduction} \label{chap_introduction}

Sinds the early days there have been challenges with creating and maintaining stable and
evolvable software. On the one hand, this is caused by constantly evolving requirements as
new business opportunities, technologies, methodologies, and best practices are developed
to meet the demands of modern corporate environments. On the other hand, changing software
can lead to deterioration in stability and evolvability, which can negatively impact the
quality of these systems. \textcite{lehman_programs_1980} has described this as one of his
laws of software evolution: The balance between the forces driving new requirements and
those that slow down progress. These challenges have been recognized by the following
pioneers in software engineering. 

\textcite{d_mcilroy_nato_1968} proposed a vision where the systematic reuse of software
building blocks should lead to more reuse. \textcite{d_mcilroy_nato_1968} quoted
\enquote{The real hero of programming is the one who writes negative code}, i.e. when a
change in a program source makes the number of lines of code decrease ('negative' code),
while its overall quality, readability or speed improves
\footnote{\url{https://en.wikipedia.org/wiki/Douglas_McIlroy}}. Perhaps very early concepts
of modular software constructs?

\textcite{dijkstra_letters_1968} argued against using unstructured control flow in
programming and advocated for using structured programming constructs to improve the
clarity and maintainability of the source code. He advocated structured programming
techniques that improved the modularity and evolvability of software artifacts.

\textcite{parnas_criteria_1972} continued with the principle of information hiding. He
stated that design decisions used multiple times by a software artifact should be
modularized to reduce complexity. 

Various programming paradigms, including procedural, object-oriented, and functional
programming, have emerged to enhance software programming capabilities that contribute to
stability and evolvability \parencite{mannaert_normalized_2016}. These paradigms have
impacted modern programming languages, such as Java and C\#, enabling the development of
more modular and evolvable software architectures.

Design principles, patterns, and theorems are, on top of all, additional measures to
enhance the modularity, stability, and evolvability of software artifacts. As a junior
software engineer, I was always intrigued by the concepts of quality and maintainable code
and quickly got introduced to the \gls{solid} principles. And later on with the complete
design approach derived from \gls{ca}. Starting my Master's degree, I got an
inspiring introduction from Jan Verelst and realized quality and maintainability were
essentially all about the concepts of stability and evolvability. For me, it was very
interesting that the \gls{ns} Theory is supported by empirical scientific evidence.
Although I'm not that active anymore in the field of software engineering, I immediately
knew the topic of my research. it is still a big passion of mine.

Given my experience with \gls{ca}, and what I was learning from \gls{ns} Theory, I noticed
a lot of similarities, but also some big differences. In early investigations, I found
overlapping characteristics. But it seemed there were also a couple of differences. I
wanted to know if the design approaches could be used in conjunction with each other,
perhaps bettering the result of stable and evolvable software.

Java SE has primarily been used for case studies in order to develop the Normalized
Systems Theory \parencite{oorts_building_2014, de_bruyn_enabling_2018}. Although
sufficient in Java, I was pleased to read that both software design approaches have
formulated their modular structures independent of any programming technology
\parencite{mannaert_normalized_2009,robert_c_martin_clean_2018}. So I was free to use my
favorite programming language C\# to create a software artifact that supported my
research, igniting my passion for programming again. 

Based on my early investigations of both design approaches I hypothesized that they can be
used in conjunction with each other. Consequently, an artifact that is designed based on
the principles of Clean Architecture will lead to a highly modular, stable, and evolvable
C\# artifact that does not contradict a design based on the Normalized Systems theorems.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/hypothesis.pdf}
    \caption[The hypothesis]{The hypothesis}
    \label{fig_hypothesis}
\end{figure}

\input{chapters/Introduction/introtons}
\input{chapters/introduction/introtoca}
\input{chapters/introduction/researchobjectives}
%\input{chapters/introduction/sections/researchquestion}
\input{chapters/introduction/researchmethod}
\input{chapters/introduction/structure}