\chapter{Introduction} \label{chap_introduction}

After my bachelor's degree in 2009, I started to work as a junior software engineer. I was
confident I was willing to accept any technical challenge as my experience up until that
point led me to believe that creating some software was not that difficult. I could not
have been more wrong. I quickly discovered it was a real challenge to apply new
requirements to existing pieces of (legacy) software or explain my craftings to the more
mature engineers. The craftsmanship of software engineering was enormously challenging to
me.

Determined to overcome the difficulties, I started reading and investigating and
immediately recognized the Law of Increasing Complexity of
\textcite{lehman_programs_1980}, where he explained the balance between the forces driving
new requirements and those that slow down progress. Other pioneers in software have
recognized these challenges in engineering also.

\textcite{d_mcilroy_nato_1968} proposed a vision where the systematic reuse of software
building blocks should lead to more reuse. \textcite{d_mcilroy_nato_1968} quoted,
\enquote{The real hero of programming is the one who writes negative code,} i.e., when a
change in a program source makes the number of lines of code decrease ('negative' code),
while its overall quality, readability or speed improves
\parencite{wikipedia_douglas_2023}. Perhaps very early concepts of modular software
constructs?

\textcite{dijkstra_letters_1968} argued against using unstructured control flow in
programming and advocated for using structured programming constructs to improve the
clarity and maintainability of the source code. In addition,
\Citeauthor{dijkstra_letters_1968} advocated structured programming techniques that
improved the modularity and evolvability of software artifacts.

\textcite{parnas_criteria_1972} continued with the principle of information hiding.
\Citeauthor{parnas_criteria_1972} stated that design decisions used multiple times by a
software artifact should be modularized to reduce complexity. 

Over the years, I got introduced to various software design principles and philosophies
like \gls{ca}, increasing my knowledge and craftsmanship. My career moved more toward the
arts of architecture and product management, and I have always retained my passion for
software engineering.

My obsession got re-ignited during my Master's degree introduction days at the Priory of
Corsendock. Jan Verelst introduced me to \gls{ns}, and I was intrigued by software
stability and evolvability. It was fascinating to learn that there is now empirical
scientific evidence for a quest I have been on for almost a decade. 

\gls{ns} Had to be the topic of my research. I was curious to compare what I knew
(\gls{ca}) with what science offered (\gls{ns}). In early investigations, I found
overlapping characteristics. Nevertheless, there were also a couple of differences. Could
these design approaches be used in conjunction with each other?

Java SE has primarily been used for case studies in order to develop the Normalized
Systems Theory \parencite{oorts_building_2014, de_bruyn_enabling_2018}. Although
sufficient in Java, I was pleased to read that both software design approaches have
formulated modular structures independent of any programming technology
\parencite{mannaert_normalized_2009,robert_c_martin_clean_2018}. So I could use my
favorite programming language C\#, to create a software artifact that supported my
research. 

Based on early investigations, I instinctively found that many applications of \gls{ca}
are a specialization of the \gls{ns} Theorems. Consequently, I hypothesized that \gls{ca}
and \gls{ns} could be used to achieve a modular, evolvable, and stable software artifact.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/hypothesis.pdf}
    \caption[The hypothesis]{The hypothesis}
    \label{fig_hypothesis}
\end{figure}

Since this research is investigating the convergence of gls{ca} and \gls{ns}, it is
relevant to introduce them and discuss the concepts mentioned in the following sections.

\input{chapters/introduction/researchmethod}
\input{chapters/introduction/researchobjectives}
\input{chapters/introduction/structure}