Manifestiations of Separation of State
\gls{sos} fits very well in distributed information systems with asynchronous calls. The
expanded artifact is designed in a manner that all external process functions are executed
asynchronously. \todo{snippet toevoegen.}.

A simpler manifestation of the \gls{sos} theorem involves the use of Resources as an
integral part solution
\footnote{url{https://learn.microsoft.com/en-us/dotnet/core/extensions/resources}}. In
addition to enabling the localization of strings, this approach offers the advantage of
centralized management, thereby exhibiting \gls{sos}. For instance, when the functional
requirements evolve, the name of a template in the expander artifact is likely to change.
As the name of the template is used in multiple class instances, a centralized approach to
managing the template name can mitigate the risk of excessive modifications when a name
change is mandated.

Another example. The state of the model (see chapter \ref{sec:artifact_model}) is
currently persisted in an Azure SQL Database.

\lstinputlisting[
    caption={The \citetitle{koks_genericrepository_2023} \parencite{koks_genericrepository_2023}}]
    {Snippets/GenericRepository.cs}

The state of of the expander artifact model as described in \ref{sec:artifact_model} for the expander in the 
voorbeeld met seerders...
voorbeeld met repositories....



ActionVersionTransparancy

Manifestations in the artifacts are abundant. One example is the
\citetitle{koks_icommandlineinteractor_2023} \parencite{koks_icommandlineinteractor_2023}.
There are multiple signatures of the processing function Start, each of them allowing a
slightly different behavior when executed.

In specific situations \enquote{Dependency Injection} can be viewed as an application of
\gls{avt}. The \citetitle{koks_logger_2023} \parencite{koks_logger_2023} is currently an
implementation of the NLOG framework \footnote{\url{https://nlog-project.org/}}. It is
fairly simple to implement a new logging framework as a replacement for NLOG when the
consuming implementations only use the ILogger interface, instead of the concrete NLOG
wrapper implementation. A warning is in order though. Dependency Injection does not remove
the dependency. It moves the dependency to a different class. When implemented incorrectly
this could even violate the \gls{avt} principle \parencite[213]{mannaert_normalized_2016}.
Therefore it is recommended only to use Dependency Injection in combination with an
\enquote{Inversion Of Control Container} where the dependencies from the viewpoint of a
module are managed centrally.

The use of Generics is another use of Polyphormismadhering to the \gls{avt} theorem.
Consider code snippet \ref{SnipICreateGateway} \nameref{SnipICreateGateway} which is a
generic implementation of the Create repository. This allows consumer code to create
entities without having dependencies on the entity itself, or without having to know the
concrete class.

\lstinputlisting[
    caption={\citetitle{koks_icreategateway_2023}},
    label={SnipICreateGateway}]
    {Snippets/ICreateGateway.cs}