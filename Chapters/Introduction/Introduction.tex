\chapter{Introduction} \label{chap_introduction}

Shortly after starting my bachelor's degree in 2008, I started to work as a junior
software engineer. I was confident I was willing to accept any technical challenge as my
experience up until that point led me to believe that creating some software was not that
difficult. I could not have been more wrong. I quickly discovered it was a real challenge
to apply new requirements to existing pieces of (legacy) software or explain my craftings
to the more mature engineers. The craftsmanship of software engineering was enormously
challenging to me.

Determined to overcome the difficulties, I started reading and investigating and
immediately recognized the Law of Increasing Complexity of
\textcite{lehman_programs_1980}, where he explained the balance between the forces driving
new requirements and those that slow down progress. Other pioneers in software have
recognized these challenges in engineering also.


\textcite{d_mcilroy_nato_1968} proposed a vision for systematically reusing software building
blocks that should lead to more reuse. \textcite{d_mcilroy_nato_1968} stated, \enquote{The real
hero of programming is the one who writes negative code,} i.e., when a change in a program
source makes the number of lines of code decrease ('negative' code), while its overall
quality, readability or speed improves \parencite{wikipedia_douglas_2023}. Perhaps very
early concepts of modular software constructs?

\textcite{dijkstra_letters_1968} argued against using unstructured control flow in
programming and advocated for using structured programming constructs to improve the
clarity and maintainability of the source code. In addition,
\Citeauthor{dijkstra_letters_1968} advocated structured programming techniques that
improved the modularity and evolvability of software artifacts.

\textcite{parnas_criteria_1972} continued with the principle of information hiding.
\Citeauthor{parnas_criteria_1972} stated that design decisions used multiple times by a
software artifact should be modularized to reduce complexity. 

Over the years, I got introduced to various software design principles and philosophies
like \gls{ca}, increasing my knowledge and craftsmanship. My career moved more toward
architecture and product management. Nevertheless, I have always retained my passion for
software Engineering.

My obsession got re-ignited during the Master's degree introduction days at the Priory of
Corsendock. Jan Verelst introduced me to \gls{ns}, and I was intrigued by software
stability and evolvability. It was fascinating to learn that there is now empirical
scientific evidence for a quest I have been on for almost a decade. 

\gls{ns} had to be the topic of my research. I was curious to compare what I knew
(\gls{ca}) with what science had to offer (\gls{ns}). In early investigations, I found
overlapping characteristics. Nevertheless, there were also a couple of differences. Could
these design approaches be used in conjunction with each other?

Java SE has primarily been used for case studies to develop the Normalized
Systems Theory \parencite{oorts_building_2014, de_bruyn_enabling_2018}. Although
sufficient in Java, I was pleased to read that both software design approaches have
formulated modular structures independent of any programming technology
\parencite{mannaert_normalized_2009,robert_c_martin_clean_2018}. So I could use my
favorite programming language, C\#, to create a software artifact that supported my
research. 

Based on early investigations, I instinctively found that many applications of \gls{ca}
are a specialization of the \gls{ns} Theorems. Therefore, \gls{ca} could be used to
achieve a modular, evolvable, and stable software artifact as defined by \gls{ns}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/hypothesis.pdf}
    \caption[My hypothesis]{The hypothesis}
    \label{fig_hypothesis}
\end{figure}

Since this research investigates the convergence of \gls{ca} and \gls{ns}, it is relevant
to introduce them and discuss the concepts mentioned in the following sections.

\input{chapters/introduction/researchmethod}
\input{chapters/introduction/researchobjectives}
\input{chapters/introduction/structure}