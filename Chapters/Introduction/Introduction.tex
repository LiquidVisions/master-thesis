\chapter{Introduction} \label{chap:introduction}

\section{Background} \label{sec:background} 

There is this notion that everything is always in motion, a constant state of flux. This
notion has been recognized for centuries and is famously described by the Greek
philosopher
\emph{Heraclitus}\footnote{\url{https://plato.stanford.edu/entries/process-philosophy/}}
with his statement \emph{Pantha Rhei} (Everything flows). This notion is particularly
relevant in the context of software engineering, as software systems must be able to
evolve and adapt to changing business requirements.

Software engineering is constantly evolving as new technologies, methodologies, and best
practices are developed to meet the demands of modern corporate environments. In this
context, the concept of software stability is a constant reality. Software systems must be
able to evolve and adapt to changing business requirements over time. However, this
evolution must be managed to maintain the stability of software artifacts.

The laws of software evolution describe the balance between the forces driving new
requirements and those that slow down progress. As a result, changing software can lead to
deterioration in stability and evolvability, which can negatively impact the quality of
these systems. Scholars have recognized this challenge for decades, and much research has
conducted to address it \parencite{lehman_programs_1980}.

\section{Related work} \label{sub:related_work}

Early pioneers in software engineering recognized the importance of modular programming
practices to improve code clarity and maintainability. James Edwin McIlroy proposed a
vision where the systematic reuse of software building blocks leads to harmful programming
practices where software changes eventually reduce complexity
\parencite{p_naur_nato_1968}. 

Dijkstra argued against using unstructured control flow in programming and advocated for
using structured programming constructs to improve the clarity and maintainability of code
\parencite{dijkstra_letters_1968}. He advocated structured programming techniques that
improved the modularity and evolvability of software artifacts. Parnas continued with the
principle of information hiding. He stated that design decisions used multiple
times by a software artifact should be modularized to reduce complexity
\parencite{parnas_criteria_1972}. 

Various programming paradigms, including procedural, object-oriented, and functional
programming, have emerged to enhance software programming capabilities. In addition, these
paradigms have impacted modern programming languages, such as Java and C\#, enabling the
development of more modular and evolvable software architectures.

\input{Chapters/Introduction/Sections/ResearchProblem.tex}
\input{Chapters/Introduction/Sections/IntroCleanArchitecture.tex}
\input{Chapters/Introduction/Sections/IntroNormalizedSystems.tex}
\input{Chapters/Introduction/Sections/Hypotesis.tex}
\input{Chapters/Introduction/Sections/ResearchObjectives.tex}
\input{Chapters/Introduction/Sections/ResearchQuestion.tex}
\input{Chapters/Introduction/Sections/ResearchMethod.tex}