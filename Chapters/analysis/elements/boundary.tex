\subsection{The Boundary Element}

\evaluateElementTable{Boundary}{tab_convergence_boundary}{ \addEvalRow{Data & \noConvergence
    &  There is no convergence between the Boundary element of \gls{ca} and the Data
    element of \gls{ns}, and no manifestations are found in the artifact.}

    \addEvalRow{ Task & \noConvergence &  There is no convergence between the Boundary element
    of \gls{ca} and the task element of \gls{ns}, and no manifestations are found in the
    artifact.}

    \addEvalRow{ Flow & \noConvergence & There is no convergence between the Boundary
    element of \gls{ca} and the Flow element of \gls{ns}, and no manifestations are found
    in the artifact.}

    \addEvalRow{Connector & \fullConvergence & The Boundary element of \gls{ca} has a strong
    convergence with the Connector element of \gls{ns}, as both are involved in communication
    between components and help ensure loose coupling between these components. However,
    the Boundary element's scope seems narrower, as this element usually separates
    architectural boundaries within the application or component. In the Code Listing
    Example \ref{list_CreateEntityBoundary} we can notice that the main purpose of the
    Boundary is to separate the inner parts of the Application layer from the Presentation
    layer, which converges with the goal of the Connector Element of \gls{ns}}
    
    \addEvalRow{ Trigger & \noConvergence & There is no convergence between the Boundary
    element of \gls{ca} and the task element of \gls{ns}, and no manifestations are found
    in the artifact.} }