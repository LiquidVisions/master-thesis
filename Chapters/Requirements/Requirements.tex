\chapter{Requirements} \label{chap_requirements} 

In this chapter, we will explain that the artifact requirements are composed of two
distinct parts. The research aims to examine the level of convergence between \gls{ca} and
\gls{ns}. As such, the design and architecture requirements are intentionally, and entirely 
based on the principles and design approach of \gls{ca}. A full description of this requirement
can be found in section \ref{sec_artifact_requirements}. In order to analyze the level of
convergence, the artifacts need to comply with the evolvability requirements of the theory
of \gls{ns}, described in section \ref{sec_research_requirements} of this chapter.

\section{Research requirements} \label{sec_research_requirements} 

In order to address the research objectives we outlined in Chapter
\ref{sec_research_objectives}, we need to know what violations in the context of \gls{ns}
can occur in a software artifact. In chapters \ref{sec_ns_theory} we have shown that
\gls{ns} attempts to achieve evolvability by achieving stability. Through the extensive
and consistent use of the \gls{ns} theorems, a modular design emerges that is free of
instabilities. Alternatively, in terms used by the \gls{ns} theorem: the absence of
combinatorial effects. However, as described in section \ref{sec_artifact_requirements},
the artifacts are designed based on the principles and design approach of \gls{ca}. The
\gls{ns} theorems are not considered using the design phase of the artifacts. 

To be able to analyze the stability of the artifacts the following functional requirement
specifications are reused \parencite[254-259]{mannaert_normalized_2016}. They are noted
without the mathematical formulas that are present in cited sources.


\mycolorbox{An information system needs to be able to represent instances of data
entities. A data entity consists of several data fields. Such a field may be a basic
data field representing a value of a reference to another data entity.}
{Research Requirement 1}

\mycolorbox{An information system needs to be able to execute processing actions on
instances of data entities. A processing action consists of several consecutive processing
tasks. Such a task may be a basic task, i.e., a unit of processing that can change
independently, or an invocation of another processing action.} {Research Requirement 2}

\mycolorbox{An information system needs to be able to input or output values of instances of data entities through connectors.}
{Research Requirement 3}

\mycolorbox{An existing information system representing a set of data entities, needs
to be able to represent: 
\begin{itemize}
    \item a new version of a data entity that corresponds to including an additional
    data field
    \item an additional data entity 
\end{itemize}}
{Research Requirement 4}

\mycolorbox{An existing information system providing a set of processing actions,
needs to be able to provide:
\begin{itemize}
    \item a new version of a processing task, whose use may be mandatory
    \item a new version of a processing action, whose use may be mandatory
    \item an additional processing task
    \item an additional processing action
\end{itemize}}
{Research Requirement 5}

section{Artifact requirements} \label{sec_artifact_requirements}

The artifacts adhere to the design approach of \gls{ca}, described in chapter
\ref{sec_ca_theory}, as much as possible. In order to do so the following
requirements are to be applied.

\subsection{Artifact components}
In \fullref{subsec_layers} we describe that in a typical application, one of the goals of
\gls{ca} is to separate the domain logic from Impl details like (user) interface
or storage mechanisms. Therefore, the artifact must follow the layered architecture of
\gls{ca} (see figure \ref{fig_modulair_components})

In the case of the \nameref{sec_generator_artifact} there are two separate infrastructure
layers. The first one has a dependency on
EntityFrameworkCore\footnote{\url{https://learn.microsoft.com/en-us/ef/core/}} technology
for data persistence in an Azure SQL database. The other one handles persistence by
serialization of data on a windows machine.

\subsection{Flow of control}
One of the \gls{solid} design principles is the \acrfull{dip}. This principle affects the.
As described in \fullref{sebsec:dependency_rule}, this affects the flow of control of the
artifacts components. To achieve the evolvability of each of the components, the flow of
control must adhere to the following statement. This is also depicted in Figure
\ref{fig_modulair_components}.

The component dependencies must point only inward, toward higher-level policies. To make
it more strict, the Presentation and infrastructure layers only depend on the Application
layer The Application layer only depends on the  Domain Layer.

\subsection{Adherence to Design principles}
In \fullref{subsec_design_principles} we describe what needs to be done to adhere to the
\gls{solid} design principles. Each design pattern that is applied to the architecture of
artifacts adheres at least to one of the \gls{solid} principles.

\subsection{Screaming Architecture}
The essence of Screaming Architecture is to design a system where the structure and
purpose of each component and layer are immediately apparent to anyone looking at it. This
is achieved through clear and consistent naming conventions of the classes, namespaces and,
components.

In the literature of \gls{ca}, there is no mention of rules or recommendations for naming
conventions. The most commonly practiced naming convention of nouns (for data entities)
and verbs (for actions) will be used. This is also advocated by the literature of \gls{ns}
\parencite[357]{mannaert_normalized_2016}.

Table \ref{table:component_naming_convention} lists the required naming convention for the
different layers, whereas table \ref{table:element_naming_convention} lists the naming
convention of the recurring elements. For more information about these elements see
\ref{subsec_design_elements}.

\begin{table}[h]
    \small
    \begin{tabular}{ l p{0.30\linewidth} p{0.43\linewidth} }
    \hline
    \textbf{Component} & \textbf{Filename} & \textbf{Namespace} \\ 
    \hline
    Domain & [Prod].Domain & [Company].[Prod].Domain \\
    Application & [Prod].Application & [Company].[Prod].Application \\
    Presentation & [Prod].Presentation.[Tech] & [Company].[Prod].Presentation.[Tech] \\
    Infrastructure & [Prod].Infrastructure.[Tech] & [Company].[Prod].Infrastructure.[Tech]
    \\ \hline
    \end{tabular}
\caption{Naming convention components}
\label{table:component_naming_convention}
\end{table}

    \begin{table}[h]
        \small
        \begin{tabular}{ l p{0.33\linewidth} p{0.39\linewidth} }
        \hline
        \textbf{Component} & \textbf{Element type} & \textbf{Naming Convention} \\ \hline
        Presentation & Controller Impl & \textit{Noun}Controller \\
        & ViewModelMapper Impl & \textit{Noun}ViewModelMapper \\
        & Presenter Impl & \textit{VerbNoun}Presenter \\
        & ViewModel Impl & \textit{Noun}ViewModel \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline

        Application & Boundary Impl & \textit{VerbNoun}Boundary \\
        & Boundary interface & IBoundary \\
        & Gateway interface & I\textit{Verb}Gateway \\
        & Interactor interface & I\textit{Verb}Interactor \\
        & Interactor Impl & \textit{VerbNoun}Interactor \\
        & Mapper Interface & IMapper \\
        & RequestModelMapper Impl & \textit{VerbNoun}RequestModelMapper \\
        & Presenter Interface & IPresenter \\
        & Validator Interface & IValidator \\
        & Validator Impl & \textit{VerbNoun}Validator \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline
        
        Infrastructure & Gateway Impl & \textit{Noun}Repository \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline

        Domain & Data Entity Impl & \textit{Noun} \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline
        \end{tabular}
        \caption{Naming convention of recurring elements}
        \label{table:element_naming_convention}
        \end{table}

    \subsection{Recurring elements}
    
    For each data entity defined in the model (see chapter \ref{subsec_artifact_model}), a
    fixed set of required elements, listed in table \ref{table:element_naming_convention}
    will be added to the appropriate component, to comply with the design of the
    architecture.

    \todo{requirement mbt code expansion toevoegen (pag 403)}