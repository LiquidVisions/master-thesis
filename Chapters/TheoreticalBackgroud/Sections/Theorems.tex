\section{Normalized Systems: Impacting software stability} 
\label{ns_theory}
\begin{itemize}
    \item Inleiding
\end{itemize}


\subsection{The Design Theorems} \label{subsec:ns_desing_theorems}

\gls{ns} Theorems is a theoretical framework of principles that aims to enhance the
stability of a software artifact. \gls{ns} provides a rigorous mathematical foundation
that offers guidelines for designing and developing software systems. The principles of NS
have gained significant attention in both academic and industrial circles due to their
potential to increase the evolvability and stability of software artifacts while reducing
maintenance costs. The theorems have been scientifically established and proven. In the
following sections, we will focus on the theorems of \gls{ns}. When applicable, we
emphasize some manifestations in one of the artifacts to demonstrate the level of
convergence of \gls{ca}.

\subsubsection{Separation of Concerns}
Since the early years of software engineering, \gls{soc} has been one of the most
fundamental software engineering principles. The principle has first been mentioned by
\citeauthor{dijkstra_selected_1982}\footnote{\url{https://en.wikipedia.org/wiki/Separation_of_concerns}}
as the crucial principle to design modular software architecture
\parencite[]{dijkstra_selected_1982}. The concept itself was introduced by
\citeauthor{parnas_criteria_1972} in his book \citetitle*{parnas_criteria_1972}.

This principle promotes the idea that a program should be divided into distinct sections,
each addressing a separate concern or aspect of the problem. This allows for a more
organized and maintainable source code, as changes to one concern do not affect the
others. \gls{soc} should be applied at the level of individual modules, rather that the level
of an entire program.

The \gls{soc} had its effect on later versions of software engineering principles like SOLID.
The principles of 'Single Responsibility' and 'Interface Segregation' are directly derived
from \gls{soc}. It also affected the theorems of Normalized Systems, although it has a more
strict definition of this principle. In the book of \citeauthor{mannaert_normalized_2016}
it is described as followed: 

\begin{center}
    \textbf{Theorem I}\\
    \textit{A processing function can only contain a single task to achieve stability.}    
\end{center}


There are a couple of manifestation examples described like the application of an
integration service bus. The manifestation of external workflows is another example. One
example of an external workflow in the prototype of this research project is the
\ref{SnipSeedingBoundary}. This class is responsible for the provision of the initial data
to the model, based on the elements of the meta-model itself. It 'seeds' the data by
orchestrating individual entity seeders to execute in the correct order.

\lstinputlisting[
    caption=\citeurl{koks_seedingboundary_2023},
    label={SnipSeedingBoundary}]
    {Snippets/Seedingboundary.cs}

\subsubsection{Data version Transparancy}
\gls{dvt} is the act of encapsulation of data entities for specific tasks at hand. This
results in the fact that data structures can have multiple versions often mentioned as
Data Transfer Objects in modern software engineering projects. In other words, it should
be possible to update the data entity without affecting the processing functions. This
leads to the following description of the theorem \parencite[280]{mannaert_normalized_2016}.

\begin{center}
    \textbf{Theorem II}\\
    \textit{A data structure that is passed through the interface of a processing function 
    needs to exhibit version transparency in order to achieve stability.}
\end{center}

\gls{dvt} is widely used in various technological applications. Every web service
currently known supports some type of versioning. In restful APIs for example, it is
common practice to support versioning over the URI. It is best practice to encapsulate
breaking changes in a new version of the endpoint/service so that the consumers are not
(directly) affected by the change. In modern Object Oriented languages, gls{dtv} is also
supported by the ability to determine the scope of visibility of the modifiers of the
various programming constructs like fields, properties, interfaces and classes. Also known
as information hiding \parencites{parnas_criteria_1972}[278]{mannaert_normalized_2016}.

The prototype also uses information hiding very strictly. In order to seal implementations
to the intended layers, concrete implementations always have internal visibility, making
them impossible to use. The interfaces on the other hand are publically exposed. The
dependent layers are now restricted to the appointed dependency injection container of the
specific layer. Alternatively, it is also possible to implement a custom implementation of
the specific interface. 

Another example from the prototype is the use of ViewModels for the queries, and
CommandModels for the commands. Depending on the context of the operation, the containing
fields of the Model may differ. A CommandModel for deleting a data entity will only
contain the key of the entity that needs to be deleted. The CommandModel for creating the
same type of entity will probably contain all the required fields of the data entities,
except the key field as this key is often auto-generated by the database or
domain layer of the application.

\subsubsection{Action version Transparancy}
\gls{avt} is the property of a system to modify existing processing functions without
affecting the existing ones. It should be possible to upgrade a function without affecting
the callers of those functions. This description leads to the following theorem
\parencite[282]{mannaert_normalized_2016}.

\begin{center}
    \textbf{Theorem III}\\
    \textit{A processing function that is called by another processing function, needs to exhibit version transparency in order to achieve stability.}
\end{center}

Most of the modern technology environments support some form of \gls{avt}. Polymorphism is
a widely used technique in order to support this theorem. Specifically, parametric
polymorphism \footnote{\url{https://en.wikipedia.org/wiki/Parametric_polymorphism}} allows
for a processing function to have multiple input parameters. There are also quite some
design patterns supporting this theorem. Some random examples are the state pattern
\footnote{\url{https://en.wikipedia.org/wiki/State_pattern}}, facade pattern
\footnote{\url{https://en.wikipedia.org/wiki/Facade_pattern}} and observer pattern
\footnote{\url{https://en.wikipedia.org/wiki/Observer_pattern}}.

Manifestations in the artifacts are abundant. One example is the
\citetitle{koks_icommandlineinteractor_2023} \parencite{koks_icommandlineinteractor_2023}.
There are multiple signatures of the processing function Start, each of them allowing a
slightly different behavior when executed.

In specific situations \enquote{Dependency Injection} can be viewed as an application of
\gls{avt}. The \citetitle{koks_logger_2023} \parencite{koks_logger_2023} is currently an
implementation of the NLOG framework \footnote{\url{https://nlog-project.org/}}. It is
fairly simple to implement a new logging framework as a replacement for NLOG when the
consuming implementations only use the ILogger interface, instead of the concrete NLOG
wrapper implementation. A warning is in order though. Dependency Injection does not remove
the dependency. It moves the dependency to a different class. When implemented incorrectly
this could even violate the \gls{avt} principle \parencite[213]{mannaert_normalized_2016}.
Therefore it is recommended only to use Dependency Injection in combination with an
\enquote{Inversion Of Control Container} where the dependencies from the viewpoint of a
module are managed centrally.

The use of Generics is another use of Polyphormismadhering to the \gls{avt} theorem.
Consider code snippet \ref{SnipICreateGateway} \nameref{SnipICreateGateway} which is a
generic implementation of the Create repository. This allows consumer code to create
entities without having dependencies on the entity itself, or without having to know the
concrete class.

\lstinputlisting[
    caption={\citetitle{koks_icreategateway_2023}},
    label={SnipICreateGateway}]
    {Snippets/ICreateGateway.cs}

\subsubsection{Separation of State}

\gls{sos} is a theorem that is based on the idea that processing functions should not
contain any state information but instead should rely on external data structures to store
state information. By separating state information from processing functions, Normalized
Systems can achieve a higher level of flexibility and adaptability. External data
structures can be updated or replaced without affecting the processing functions
themselves, which greatly reduces the change of unwanted ripple effects. This theorem is
described as followed: \parencite[258]{mannaert_normalized_2016}.

\begin{center}
    \textbf{Theorem IV}\\
    \textit{Calling a processing function within another processing function, needs to exhibit state keeping in order to achieve stability.}
\end{center}

\gls{sos} fits very well in distributed information systems with asynchronous calls. The
expanded artifact is designed in a manner that all external process functions are executed
asynchronously. \todo{snippet toevoegen.}.

A simpler manifestation of the \gls{sos} theorem involves the use of Resources as an
integral part solution
\footnote{url{https://learn.microsoft.com/en-us/dotnet/core/extensions/resources}}. In
addition to enabling the localization of strings, this approach offers the advantage of
centralized management, thereby exhibiting \gls{sos}. For instance, when the functional
requirements evolve, the name of a template in the expander artifact is likely to change.
As the name of the template is used in multiple class instances, a centralized approach to
managing the template name can mitigate the risk of excessive modifications when a name
change is mandated.

Another example. The state of the model (see chapter \ref{sec:artifact_model}) is
currently persisted in an Azure SQL Database.

\lstinputlisting[
    caption={The \citetitle{koks_genericrepository_2023} \parencite{koks_genericrepository_2023}}]
    {Snippets/GenericRepository.cs}

The state of of the expander artifact model as described in \ref{sec:artifact_model} for the expander in the 
voorbeeld met seerders...
voorbeeld met repositories....



\subsection{Architecture elements} \label{subsec:ns_elements} 

\textbf{Data Element}\\
This is an object that represents a piece of data in the system. Data elements are used to
pass information between processing functions and other objects. In Normalized Systems,
data elements are typically standardized to ensure consistency across the system.

\textbf{Flow Element}\\
This object represents the flow of control through the system. It determines the order in
which processing functions are executed and can be used to handle error conditions or
other exceptional cases.

\textbf{Connector Element}\\
This object is used to connect different parts of the system together. Connectors can be
used to link processing functions, data elements, and other objects, allowing them to work
together seamlessly.

\textbf{Task Element}\\
This is an object that represents a specific task or action in the system. Tasks can be
composed of one or more processing functions and can be used to represent complex
operations within the system.
