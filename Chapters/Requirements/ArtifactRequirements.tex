\section{Artifact requirements} \label{sec:artifact_requirements}

The artifacts adhere to the design philosophy of \gls{ca}, described in chapter
\ref{sec:ca_theory}, as much as possible. In order to do so the following
requirements are to be applied.

\subsection{Artifact components}
In \fullref{subsec:layers} we describe that in a typical application, one of the goals of
\gls{ca} is to separate the domain logic from Impl details like (user) interface
or storage mechanisms. Therefore, the artifact must follow the layered architecture of
\gls{ca} (see figure \ref{fig:modulair_components})

In the case of the \nameref{chap:generator_artifact} there are two separate infrastructure
layers. The first one has a dependency on
EntityFrameworkCore\footnote{\url{https://learn.microsoft.com/en-us/ef/core/}} technology
for data persistence in an Azure SQL database. The other one handles persistence by
serialization of data on a windows machine.

\subsection{Flow of control}
One of the \gls{solid} design principles is the \acrfull{dip}. This principle affects the.
As described in \fullref{sebsec:dependency_rule}, this affects the flow of control of the
artifacts components. To achieve the evolvability of each of the components the flow of
control must adhere to the following statement. This is also depicted in Figure
\ref{fig:modulair_components}.

The component dependencies must point only inward, toward higher-level policies. To make
it more strict, the Presentation and infrastructure layers only depend on the Application
layer The Application layer only depends on the  Domain Layer.

\subsection{Adherence to Design principles}
In \fullref{subsec:design_principles} we describe what needs to be done to adhere to the
\gls{solid} design principles. Each design pattern that is applied to the architecture of
artifacts adheres at least to one of the \gls{solid} principles.

\subsection{Screaming Architecture}
The essence of Screaming Architecture is to design a system where the structure and
purpose of each component and layer are immediately apparent to anyone looking at it. This
is achieved through clear and consistent naming conventions of the classes, namespaces and
components.

In the literature of \gls{ca} there is no mention of rules or recommendations for naming
conventions. The most commonly practiced naming convention of nouns (for data entities)
and verbs (for actions) will be used. This is also advocated by the literature of \gls{ns}
\parencite[357]{mannaert_normalized_2016}.

Table \ref{table:component_naming_convention} lists the required naming convention for the
different layers, whereas table \ref{table:element_naming_convention} lists the naming
convention of the recurring elements. For more information about these elements see
\ref{subsec:design_elements}.

\begin{table}[h]
    \small
    \begin{tabular}{ l p{0.30\linewidth} p{0.43\linewidth} }
    \hline
    \textbf{Component} & \textbf{Filename} & \textbf{Namespace} \\ 
    \hline
    Domain & [Prod].Domain & [Company].[Prod].Domain \\
    Application & [Prod].Application & [Company].[Prod].Application \\
    Presentation & [Prod].Presentation.[Tech] & [Company].[Prod].Presentation.[Tech] \\
    Infrastructure & [Prod].Infrastructure.[Tech] & [Company].[Prod].Infrastructure.[Tech]
    \\ \hline
    \end{tabular}
\caption{Naming convention components}
\label{table:component_naming_convention}
\end{table}

    \begin{table}[h]
        \small
        \begin{tabular}{ l p{0.33\linewidth} p{0.39\linewidth} }
        \hline
        \textbf{Component} & \textbf{Element type} & \textbf{Naming Convention} \\ \hline
        Presentation & Controller Impl & \textit{Noun}Controller \\
        & ViewModelMapper Impl & \textit{Noun}ViewModelMapper \\
        & Presenter Impl & \textit{VerbNoun}Presenter \\
        & ViewModel Impl & \textit{Noun}ViewModel \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline

        Application & Boundary Impl & \textit{VerbNoun}Boundary \\
        & Boundary interface & IBoundary \\
        & Gateway interface & I\textit{Verb}Gateway \\
        & Interactor interface & I\textit{Verb}Interactor \\
        & Interactor Impl & \textit{VerbNoun}Interactor \\
        & Mapper Interface & IMapper \\
        & RequestModelMapper Impl & \textit{VerbNoun}RequestModelMapper \\
        & Presenter Interface & IPresenter \\
        & Validator Interface & IValidator \\
        & Validator Impl & \textit{VerbNoun}Validator \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline
        
        Infrastructure & Gateway Impl & \textit{Noun}Repository \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline

        Domain & Data Entity Impl & \textit{Noun} \\
        & DI Bootstrapper & DependencyInjectionBootstrapper \\ \hline
        \end{tabular}
        \caption{Naming convention of recurring elements}
        \label{table:element_naming_convention}
        \end{table}

    \subsection{Recurring elements}
    
    For each data entity defined in the model (see chapter \ref{sec:artifact_model}), a
    fixed set of required elements, listed in table \ref{table:element_naming_convention}
    will be added to the appropriate component, in order to comply with the design of the
    architecture.

    \todo{requirement mbt code expansion toevoegen (pag 403)}