\chapter{Introduction} \label{chap:introduction}

\section{Background} \label{sec:background} 

There is this notion that everything is always in motion, a constant state of flux. This
has been recognized for centuries and is famously described by the Greek philosopher
\emph{Heraclitus}\footnote{\url{https://plato.stanford.edu/entries/process-philosophy/}}
with his statement \emph{Pantha Rhei} (Everything flows). This notion is particularly
relevant in the context of software engineering, as software systems must be able to
evolve and adapt to changing business requirements.

The field of software engineering is constantly evolving too, as new technologies,
methodologies, and best practices are developed to meet the demands of modern corporate
environments. In this context, the concept of software stability is a constant reality.
Software systems must be able to evolve and adapt to changing business requirements over
time. However, this evolution must be managed in a way that maintains the stability of
software artifacts.

The laws of software evolution describe the balance between the forces driving new
requirements and those that slow down progress \citeauthor*{lehman_programs_1980}.
Changing software can lead to deterioration in stability and evolvability, which can
negatively impact the quality of these systems. This challenge has been recognized by
scholars for decades, and much research has been conducted to address it.

\section{Related work} \label{sub:related_work}

Early pioneers in software engineering recognized the importance of modular programming
practices to improve code clarity and maintainability. James Edwin McIlroy proposed a
vision where the systematic reuse of software building blocks leads to negative
programming practices where software changes eventually lead to a reduction of complexity
\parencite{p_naur_nato_1968}. 

Dijkstra argued against the use of unstructured control flow in programming and advocated
for the use of structured programming constructs to improve the clarity and
maintainability of code \parencite{dijkstra_letters_1968}. He advocated structured
programming techniques that improved the modularity and evolvability of software
artifacts. Parnas continued with the principle of information hiding. He stated that
design decisions that are used multiple times by a software artifact should be modularized
in order to reduce complexity \parencite{parnas_criteria_1972}. 

Various programming paradigms, including procedural, object-oriented, and functional
programming, have emerged to enhance software programming capabilities. These paradigms
have impacted modern programming languages, such as Java and C\#, enabling the development
of more modular and evolvable software architectures. 

\input{Chapters/Introduction/Sections/ResearchProblem.tex}
\input{Chapters/Introduction/Sections/IntroCleanArchitecture.tex}
\input{Chapters/Introduction/Sections/IntroNormalizedSystems.tex}
\input{Chapters/Introduction/Sections/Hypotesis.tex}
\input{Chapters/Introduction/Sections/ResearchObjectives.tex}
\input{Chapters/Introduction/Sections/ResearchQuestion.tex}
\input{Chapters/Introduction/Sections/ResearchMethod.tex}