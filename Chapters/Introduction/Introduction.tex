\chapter{Introduction} \label{introduction}

\section{Preamble} \label{sec:preamble}

One of the constants in life is the notion that everything in life is constantly in
motion, nothing ever stays the same. Plato states that \enquote*{Patha Rhei} is one of the
famous philosophical statements first described by the Greek philosopher
\emph{Heraclitus}\footnote{\url{https://plato.stanford.edu/entries/process-philosophy/}}.
His statement unambiguously describes the dynamics of everything that exists. The
\enquote{flux}, or \emph{change} is one of the constants in life. 

According to most scholars, this most certainly also applies to modern corporate
environments where change is continuously introduced at an ever-increasing pace. These
changes lead to an evolution of requirements impacting the evolvability, stability and
quality of software artifacts like Information Systems.

The laws of software evolution refer to a series of laws that describes the balance
between the forces driving new requirements on the one hand, and the forces that slow down
progress on the other hand. In other words: changing software leads to the deterioration of
stability and evolvability, possibly with a negative effect on the desired quality of
these software systems. \citeauthor*{lehman_programs_1980}

More than a half of century of software engineering-, and architecture practices show that
the complexity of these software artifacts gradually increases over time. Eventually, this
will render most of the software artifacts obsolete, according to
\citeauthor{lehman_programs_1980}.

Historically, a lot of research has been done to solve the problem of the deterioration of
Software Artifact. McIlroy proposed a vision where the systematic reuse of software
building blocks leads to negative programming practices where software changes eventually
lead to a reduction of complexity \parencite{p_naur_nato_1968}. 

Dijkstra argued against the use of unstructured control flow in programming and advocated
for the use of structured programming constructs to improve the clarity and
maintainability of code \parencite{dijkstra_letters_1968}. Later in his career, he
advocated structured programming techniques that improved the modularity and evolvability
of software artifacts.

Parnas continued with the principle of information hiding. He stated that design decisions
that are used multiple times by a software artifact should be modularized in order to
reduce complexity \parencite{parnas_criteria_1972}. 

Over the last decades, several programming paradigms had had a significant effect on the
modularity, stability and evolvability of software systems. Procedural programming was one
of the first paradigms to emerge that supported modularity in its constructs. This was
then followed by object-oriented introducing the support for encapsulation and
polymorphism. functional programming. All of which had a significant impact on modern
programming languages like Java and C\#. The constructs of these programming languages
significantly enhanced the capabilities of modular and evolvable software architectures. 

\input{Chapters/Introduction/Sections/ResearchProblem.tex}
\input{Chapters/Introduction/Sections/IntroCleanArchitecture.tex}
\input{Chapters/Introduction/Sections/IntroNormalizedSystems.tex}
\input{Chapters/Introduction/Sections/Hypotesis.tex}
\input{Chapters/Introduction/Sections/ResearchObjectives.tex}
\input{Chapters/Introduction/Sections/ResearchQuestion.tex}
\input{Chapters/Introduction/Sections/ResearchMethod.tex}