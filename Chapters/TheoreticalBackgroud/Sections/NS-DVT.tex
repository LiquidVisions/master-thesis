\subsubsection{Data version Transparancy}

\gls{dvt} is the act of encapsulation of data entities for specific tasks at hand. This
results in the fact that data structures can have multiple versions often mentioned as
Data Transfer Objects in modern software engineering projects. In other words, it should
be possible to update the data entity without affecting the processing functions. This
leads to the following description of the theorem \parencite[280]{mannaert_normalized_2016}.

\begin{tcolorbox}
    \begin{center}
        \textbf{Theorem II}\\
        \textit{A data structure that is passed through the interface of a processing function 
        needs to exhibit version transparency in order to achieve stability.}
    \end{center}    
\end{tcolorbox}

\gls{dvt} is widely used in various technological applications. practically every web
service currently known supports some type of versioning. In restful APIs for example, it
is common practice to support versioning over the URI. It is considered a best practice
to encapsulate breaking changes in a new version of the endpoint/service so that the
consumers are not (directly) affected by the change. In modern Object Oriented languages,
gls{dtv} is also supported by the ability to determine the scope of visibility of the
modifiers of the various programming constructs like fields, properties, interfaces and
classes. Also known as information hiding
\parencites{parnas_criteria_1972}[278]{mannaert_normalized_2016}.

The prototype also uses information hiding very strictly. In order to seal implementations
to the intended layers, concrete implementations always have internal visibility, making
them impossible to use. The interfaces on the other hand are publically exposed. The
dependent layers are now restricted to the appointed dependency injection container of the
specific layer. Alternatively, it is also possible to implement a custom implementation of
the specific interface. 

Another example from the prototype is the use of ViewModels for the queries, and
CommandModels for the commands. Depending on the context of the operation, the containing
fields of the Model may differ. A CommandModel for deleting a data entity will only
contain the key of the entity that needs to be deleted. The CommandModel for creating the
same type of entity will probably contain all the required fields of the data entities,
except the key field as this key is often auto-generated by the database or
domain layer of the application.